## Extra 컬럼
- 컬럼의 이름과 달리 실행 계획에서 성능에 관련된 중요한 내용이 자주 표시된다.
- 고정된 몇개의 문장이 표시되는데, 일반적으로 2~3개씩 함께 표시된다.

### const row not found
- `const` 접근 방법으로 테이블을 읽었지만 실제로 테이블에 레코드가 1건도 존재하지 않는 경우

### Deleting all rows
- MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우
- WHERE절이 없는 DELETE 문장의 실행 계획에서 자주 표시된다. 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)을 한번 호출함으로써 처리됐다는 것을 의미한다.
- 8.0 버전에는 InnoDB, MyISAM 모두 실행계획에 표시되지 않는다. (TRUNCATE TABLE을 권장)

### Distinct
- DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인한 경우

### FirstMatch
- 세미 조인의 FirstMatch 전략이 사용되었을 경우 `FirstMatch(table_name)`메시지를 출력한다
- 함께 표시되는 테이블명은 기준 테이블을 의미한다.

### Full scan on NULL key
- `col1 IN (SELECT col2 FROM ...)`과 같은 조건을 가진 쿼리에서 col1의 값이 `NULL`이 된다면 결과적으로 조건이 `NULL IN (SELECT col2 FROM...)`와 같이 바뀐다.
- SQL 표준에서는 `NULL`을 "알수없는 값"으로 정의하고 있고 연산의 규칙까지 정의하고 있다.
  - 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
  - 서브쿼리가 1건도 레코드를 가지지 않는다면 최종 비교 결과는 FALSE
- 쿼리를 실행하는 중 col1이 `NULL`을 만나면 차선책으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드이다.
- col1이 `NOT NULL`로 정의된 컬럼이라면 위에 차선책도 사용되지 않고 Extra컬럼에도 표시되지 않는다.
- 또는 col1이 절대로 `NULL`이 될수 없다는 것을 옵티마이저에게 알려주면 된다(col1 IS NOT NULL)
- 해당 코멘트가 표시되었다고 해도 좌변의 값에 실제로 NULL이 없다면 서브쿼리 안에 테이블에 대해 풀 테이블 스캔을 발생하지 않는다.

### Impossible HAVING
- 쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 경우

### Impossible WHERE
- WHERE 조건이 항상 FALSE가 될 수밖에 없는 경우

### LooseScan
- 세미 조인의 LooseScan 최적화 전략이 사용된 경우

### No matching min/max row
- MIN(), MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없는 경우
- MIN(), MAX() 결과로 `NULL`이 반환

### No matching row in const table
- 조인할 때 `const`방법으로 접근할 때 일치하는 레코드가 없는 경우

### No matching rows after partition pruning
- 파티션된 테이블에 대한 UPDATE/DELETE 명령의 실행 계획에서 표시될 수 있는데, 해당 파티션에서 UPDATE/DELETE할 대상 레코드가 없을 경우

### No tables used
- FROM 절이 없는 쿼리 문장이나 `FROM DUAL`(컬럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블)형태의 쿼리 실행 계획의 경우
- MySQL 서버는 FROM절이 없는 쿼리도 허용된다.

### Not exists
- NOT IN(subquery), NOT EXISTS 같은 안티조인(Anti-JOIN)을 수행하는 경우
- 레코드 건수가 많을 때에는 아우터 조인을 사용해서 빠른 성능을 노려볼 수 있다.
- 테이블을 조인할 때 대상 테이블에 레코드가 존재하는지 아닌지만 판단한다.

### Plan isn`t ready yet
- 다른 커넥션에서 실행 중인 쿼리의 실행 계획을 확인할 수 있는데 이때 발생할 수 있는 메시지로 쿼리의 실행 계획을 아직 수립하지 못한 상태이다.

### Range checked for each record(index map:N)
- 레코드마다 인덱스 레인지 스캔을 체크한다는 의미
- index map은 16진수로 표시된다. 해석을 위해서는 이진수로 변환해야 한다.
- 해당 메시지가 표시되면 `type`컬럼은 `ALL`로 표시되는데 index map에 표시된 후보 인덱스를 사용할지 여부를 검토해서 후보 인덱스가 별로 도움이 되지 않는다면 최종적으로 풀 테이블 스캔을 사용하기 때문에 `ALL`로 표시된다.
- index map을 이진수로 변환했을 때 각 자릿수는 `CREATE TABLE tb ..`명령에 나열된 인덱스의 순번을 의미하고 각 자릿수의 값이 1인 인덱스를 사용 가능한 인덱스 후보로 선정했다는 의미이다.
- 하지만 실제로 어떤 인덱스가 사용됐는지는 알 수 없다..

>`No matching ...` 이나 `Impossible WHERE..`등의 메시지는 단지 쿼리의 실행 계획을 산출하기 위한 기초 자료가 없음을 표현하는 것일 뿐이다. 실제 쿼리가 문법적으로 오류가 있는 것은 아니나 쿼리 처리를 위한 데이터가 없다는 의미이므로 비지니스적으로 잘못된 것인지 확인해볼 필요는 있다.

### 