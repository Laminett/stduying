## 인비저블 인덱스(use_invisible_indexes)
- 이전에는 인덱스가 존재하면 항상 옵티마이저가 실행 계획을 수립할 때 해당 인덱스를 검ㅌ토하고 사용했다. MySQL 8.0 버전 부터는 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공한다.
- `use_invisible_indexes` 옵티마이저 옵션을 이용하면 INVISIBILE로 설정된 인덱스라 하더라도 옵ㅌ티마이저가 사용하게 제어할 수 있다.

## 스킵 스캔(skip_scan)
- 인덱스를 구성하는 컬럼의 순서가 매우 중요하고, 쿼리에 따라 해당 인덱스를 사용할 수 있을지 없을지 나뉘게 된다. 인덱스 스킵 스캔은 제한적이긴 하지만 인덱스의 이런 제약 사항을 뛰어넘을 수 있는 최적화 방법이다.
- 인덱스의 선행 컬럼이 조건절에 사용되지 않더라도 후행 컬럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다.
- 하지만 인덱스의 선행 컬럼이 매우 다양한 값을 가지는 경우에는 인덱스 스킵 스캔 최적화가 비효율 적일 수 있다. 그래서 MySQL 옵티마이저는 인덱스의 선행 컬럼이 소수의 유니크한 값을 가질때만 인덱스 스킵 스캔 최적화를 사용한다.

## 해시 조인(hash_join)
- 해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다. 따라서 해시 조인은 최고 스루풋(Best Throughput)전략에 적합하다.
- 일반 적인 웹서비스는 온라인 트랜잭션(OLTP)서비스이기 때문에 스루풋도 중요하지만 응답 속도가 더 중요하다. 그리고 분석과 같은 서비스는 사용자의 응답 시간보다는 전체적으로 처리 소요 시간이 중요하기 때문에 응답 속도보다는 전체 스루풋이 중요하다
- MySQL 8.0.17 버전까지는 해시 조인 기능이 없어 조인 조건이 좋지 않은 경우 블록 네스티드 루프 조인 알고리즘을 사용했다. 블록 네스티드 루프 조인도 쿼리의 조인 조건이 인덱스를 제대로 활용할 수 없는 경우에만 사용되는 최적화 방법 수준으로 사용되어 잘 설계된 인덱스를 가진 데이터베이스에서는 블록 네스티드 루프 조인 실행 계획은 거의 볼 수 없다.
- 그래서 이후 동등 조인을 위해 해시 조인이 사용되었지만 안티 조인이나 세미 조인을 위해서는 블록 네스티드 루프 조인이 사용되었다. 하지만 MySQL 8.0.20버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고 네스티드 루프 조인을 사용할 수 없는 경우에는 항상 해시 조인이 사용되도록 바뀌었다.
- 8.0.20 버전부터는 `block_nested_loop` 같은 `optimizer_switch` 또는 BNL과 NO_BNL 같은 힌트들도 해시 조인을 유도하는 목적으로 사용된다
- 해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리된다.
  - 빌드 단계: 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성(빌드)하는 작업을 수행한다. 빌드 단계에서 해시 테이블을 만들 때 사용되는 원본 테이블을 빌드 테이블이라고도 한다.
  - 프로브 단계: 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정을 의미한다. 이 때 읽는 나머지 테이블을 프로브 테이블이라고도 한다.
  하지만 실행계획에서는 빌드 테이블과 프로브 테이블을 식별하기 어려워 `EXPLAIN FORMAT=TREE`, `EXPLAIN ANALYZE` 명령을 통해 좀더 쉽게 구분할 수 있다.


## 인덱스 정렬 선호(prefer_ordering_index)
- MySQL 옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 인덱스의 가중치를 높이 설정해서 실행된다.
- 옵티마이저가 항상 최적의 결과를 선택하는 것이 아니여서 비효율 적으로 실행 계획을 선택할 가능성도 존재한다.
- 8.0.20 버전까지는 다른 실행 계획을 사용하게 하기 위해 특정 인덱스(ORDER BY를 위한 인덱스)를 사용하지 못하도록 `IGNORE INDEX`힌트를 사용하거나 했지만 8.0.21 버전부터는 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 `prefer_ordering_index` 옵티마이저 옵션이 추가됐다.

## 조인 최적화 알고리즘
- Exhaustive 검색 알고리즘
  - FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다. 만약 테이블이 20개라면 이 방법으로 처리했을 때 가능한 조인 조합은 모두 20!(Factorial, 3628800)개가 된다
  - 해당 알고리즘은 테이블이 10개만 넘어도 실행 계획을 수립하는데 몇분이 걸린다. 그리고 10개에서 1개만 더 늘어나도 11배의 시간이 걸린다.
- Greedy 검색 알고리즘
  1. `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
  2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
  3. 2번에서 선정된 실행 계획의 첫 번재 테이블을 "부분 실행 계획"의 첫 번째 테이블로 선정
  4. 전체 N-1개 테이블중(3번에서 선택한 테이블 제외)에서 `optimizer_search_depth` 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
  5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 "부분 실행 계획"에 대입해 실행 비용을 계산
  6. 5번의 비용 계산 결과, 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 "부분 실행 계획"의 두 번재 테이블로 선정
  7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복 실행하면서 "부분 실행 계획"에 테이블의 조인 순서를 기록
  8. 최종적으로 "부분 실행 계획"이 테이블의 조인 순서로 결정됨