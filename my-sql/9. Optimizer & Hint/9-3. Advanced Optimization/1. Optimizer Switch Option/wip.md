## 테이블 풀-아웃
- 세미조인 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
- 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법
> 실행계획에서 id컬럼의 값이 동일한 값을 가진다는 것은 두 테이블이 서브쿼리 형태가 아니라 조인으로 처리됐음을 의미
- Table pullout은 별도로 실행 계획의 Extra컬럼에 `Using table pullout`과 같은 문구가 출력되지 않기 때문에 id값을 비교해보거나 EXPLAIN명령을 싱행한 직후 `SHOW WARNINGS`명령으로 옵티마이저가 재작성한 쿼리를 살펴보는게 간편하다
> 최적화 제한사항
> - 세미 조인 서브쿼리에서만 사용가능
> - 서브쿠리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능
> - 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것은 아니므로 MySQL에서는 Table pullout 최적화를 최대한 적용한다
> - 서브쿼리의 테이블을 아우터 쿼리로 가져와서 조인으로 풀어쓰는 최적화를 수행하는데, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다
> - MySQL에서는 `최대한 서브쿼리를 조인으로 풀어서 사용해라`라는 튜닝 가이드가 많고 Table pullout은 해당 가이드를 그대로 실행하는 것이기 때문에 서브쿼리를 조인으로 풀어서 사용할 필요가 없다.


## 퍼스트 매치(firstmatch)
- IN(subquery) 형태의 세미 조인을 EXIST(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
- `optimizer_switch`변수에서 `semijoin`,`firstmatch` 두가지 옵션이 모두 ON으로 활성화된 경우에만 사용할 수 있다.
> IN-to-EXISTS vs firstmatch
> - 여러테이블이 조인되는 경우 원래 쿼리에는 없던 동등 조건을 옵티마이저가 자동으로 추가하는 형태의 최적화가 실행되기도 한다. 기존의 IN-to-EXISTS최적화에서는 이러한 동등 조건 전파가 서브쿼리 내에서만 가능했지만 FirstMatch에서는 조인 형태로 처리되기 때문에 서브쿼리뿐만 아니라 아우터 쿼리의 테이블까지 전파될 수 있어서 더 나은 실행 계획을 수립할 수 있다.
> - IN-to-EXISTS 변환 최적화 전략에서는 아무런 조건 없이 변환이 가능한 경우에는 무조건 그 최적화를 수행했다. 하지만 FirstMatch 최적화에서는 서브쿼리의 모든 테이블에 대해 FirstMatch 최적화를 수행할지 아니면 일부 테이블에 대해서만 수행할지 취사선택할 수 있다는 것이 장점이다.
> 최적화 제한사항
> - 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로이기 때문에 FirstMatch 최적화에서 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
> - 실행 계획의 Extra컬럼에는 `FirstMatch(table-N)`문구가 표시된다.
> - 상관 서브쿼리(Correlated subquery)에서도 사용될 수 있다.
> - GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다


## 루스 스캔(loosescan)
- 루스 인덱스 스캔과 비슷한 읽기 방식을 사용한다.
- 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그 다음으로 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다. 그래서 서브쿼리 부분이 루스 인덱스 스캔을 상둉할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다. 


## 구체화(Materialization)
- 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화하는 방식이고, 내부 임시 테이블을 생성한다는 것을 의미한다.
- 다른 서브쿼리 최적화와는 달리 서브쿼리 내에 GROUP BY절이 있어도 최적화 전략을 사용할 수 있다.
> 최적화 제한사항
> - IN(subquery)에서 서브쿼리는 상관 서브쿼리(Correlated subquery)가 아니여야 한다.
> - 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
> - 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.
> - 세미 조이닝 아닌 서브쿼리의 최적화에서도 구체화를 이용한 최적화가 사용될 수 있으나 `optimizer_switch` 변수의 `materialization`옵션이 OFF로 비활성화 된다면 세미 조인이 아닌 서브쿼리 최적화에서도 구체화를 이용한 최적화는 사용할 수 없다.


## 중복제거(Duplicated Weed-out)
- 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화
- Extra컬럼에 `Start temporary`, `End temporary`문구가 별도로 표기된다. Start ~ End문구의 구간이 Duplicated Weedout 최적화의 처리과정이라고 볼 수 있다.
> 최적화 제한사항
> - 서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있다
> - 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
> - 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.


## 컨디션 팬아웃(condition_fanout_filter)
- 조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다. 따라서 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.
- WHERE 조건절에 사용된 컬럼에 대해 인덱스가 있는경우, 히스토그램이 존재하는 경우 옵티마이저는 해당 조건을 만족하는 레코드의 비율을 계산할 수 있다.
> 실행계획 수립시 선택하는 순서
> 1. 레인지 옵티마이저를 이용한 예측
> 2. 히스토그램을 이용한 예측
> 3. 인덱스 통계를 이용한 예측
> 4. 추측에 기반한 예측
> 레인지 옵티마이저는 실제 인덱스의 데이터를 살펴보고 레코드 건수를 예측하는 방식인데, 실제 쿼리가 실행되기도 전에 실행 계획을 수립 단계에서 빠르게 소량의 데이터를 읽어보는 것이다. 레인지 옵티마이저에 의한 예측은 인덱스를 이용해서 쿼리가 실행될수 있을 때만 사용된다. 레인지 옵티마이저를 이용한 예측이 히스토그램이나 인덱스의 통계 정보보다 우선순위가 높기 때문에 실행계획에 표시되는 레코드 건수가 테이블이나 인덱스의 통계, 히스토그램 정보와 다른 값이 표시될 수도 있다.


## 파생 테이블 머지(derived_merge)
- FROM절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리하고 FROM절에 사용된 서브쿼리를 파생 테이블(Derived Table)이라고 부른다. 실행 계획 select_type에 `DERIVED`로 표시됨
- 내부적으로 생성되는 임시테이블은 처음에는 메모리에 생성되지만, 임시 테이블에 저장될 레코드 건수가 많아지면 결국 디스크로 다시 기록되어야 하고 이는 임시 테이블로 레코드를 복사하고 읽는 오버헤드로 인해 쿼리 성능이 저하된다.
- derived_merge 최적화 옵션은 위에 단점들을 보완하가 위해 도입된 최적화이다. derived_merge를 사용한 최적화를 사용할 시 실행계획에 `DERIVED`였던 부분이 없어지고 옵티마이저가 서브쿼리부분을 외부쿼리로 병합하여 단순 조회 계획으로 바뀌게 된다.
> 최적화 제한사항
> 항상 옵티마이저가 자동으로 서브쿼리를 외부쿼리로 병합할 수 없다.
> 아래와 같은 상황에서는 서브쿼리를 외부 쿼리로 수동으로 병합해서 작성하는게 쿼리 성능 향상에 도움이 된다.
> - SUM(), MIN(), MAX()같은 집계 함수와 윈도우 함수(Window Function)사용된 서브쿼리
> - DISTINCT가 사용된 서브쿼리
> - GROUP BY나 HAVING이 사용된 서브쿼리
> 
